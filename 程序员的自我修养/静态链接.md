# 编译和链接

[TOC]

应用程序的生成过程可以分解为**4个步骤**：

1. 预处理（Preprocessing）
2. 编译（Compilation）
3. 汇编（Assembly）
4. 链接（Linking）

## 预处理

预编译后的文件扩展名为 .ii。

预编译过程主要处理源代码文件中以 `#` 开头的预编译指令。主要规则有：

- 将所有`#define` 命令删除，展开所有宏定义；
- 处理所有条件预编译指令；
- 处理 `#include` 预编译指令，该过程时**递归**执行的；
- 删除所有注释；
- 添加行号和文件名标识；
- 保留所有`#pragma` 指令供编译器使用。

## 编译

编译过程就是把处理完的文件进行一系列的词法分析、语法分析、语义分析和优化，生成相应的**汇编代码**文件。

> `gcc` 命令指示后台程序的包装，其根据不同的参数调用预编译程序cc1，汇编器as 和链接器ld。

## 汇编

汇编就是将汇编代码转变为机器可以执行的机器指令。每一个汇编指令几乎就对应着一条机器指令。

## 链接

链接即是把用到的各个源文件（包含系统文件）链接到一起从而产生可执行文件的过程。

## 编译过程详解

编译过程一般可以分成6步：扫描，语法分析，语义分析，源代码优化，代码生成和目标代码优化。

示例：

```c++
array[index] = (index + 4) * (2 + 6);
```

### 词法分析

文件被输入到**扫描器**（一种**有限状态机**），将源代码的字符分割为一系列**记号**（token）。

记号可以分为：关键字，标识符，常量和符号等。

程序：lex。

### 语法分析

使用**语法分析器**来对生成的记号进行语法分析，从而产生**语法树**。整个过程采用**上下文无关语法**。

由语法分析器产生的语法树是以**表达式为节点**的树。

符号和数字是最小的表达式，通常就是整个语法书的**节点**；

![屏幕快照 2018-08-25 10.17.42](屏幕快照 2018-08-25 10.17.42.png)

### 语义分析

语法分析之完成了对表达式的语法层面的分析，并不了解该语句是否真正有意义。

> 编译器所能分析的语义为**静态语义**，即在编译期可以确定的语义。**动态语义**则是只有在运行期才可以确定的语义。

静态语义分析一般包括：声明和类型的匹配，类型转换等等。

经过语义分析后，整个语法树的表达式都被标识了类型。如果需要类型转换，则会在语法树中插入相应的节点。

### 中间语言生成

现代编译器包含很多层次的优化。这里只关注**源码级优化**。

源码级优化器一般把语法树转换为**中间代码**（语法树的顺序表示，与目标机器和运行时环境无关）。中间代码一般有**三地址码**和**P-代码**等形式。以三地址码为例，其格式为：x = y *op* z。

源码：

```c++
t1 = 2 + 6;
t2 = index + 4;
t3 = t2 * t1;
array[index] = t3;
```

优化后：

```c++
t2 = index + 4;
t2 = t2 * 8;
array[index] = t2;
```

中间代码使编译器分为**前端**和**后端**：前端负责产生和机器无关的中间代码；后端将中间代码转换成目标机器代码。

### 目标代码生成和优化

该部分属于编译器后端，主要包括**目标代码生成器**和**目标代码优化器**。

生成器将中间代码转换为目标机器代码；优化器对该代码进行优化。

------

编译器吧一个源代码文件编译为一个为链接对目标文件，由链接器最终将这些目标文件链接起来生成可执行文件。

链接的**主要内容**就是把各个模块之间相互引用的部分处理好，使得各个模块之间可以正确的衔接。**主要过程**包括：地址和空间分配，符号决议（或叫符号绑定）和重定位。

# 目标文件内容

PC 平台流行的**可执行文件格式**（executable）主要是Windows下的PE (Portable Executable) 和Linux下的ELF (Executable Linkable Format)，都是COFF格式的变种。

包括动态链接库（DLL）和静态链接库都按照可执行文件格式存储。

## 格式

目标文件按不同信息的属性，以**段**的形式储存。

- 程序源代码（包含局部变量）编译后的机器指令放在**代码段** .text 中；
- 全局变量和静态局部变量一般放在**数据段** .data;
- 未初始化的全局变量和静态局部变量放在 .bss 段中：.bss段只为为初始化的全局变量和局部静态变量预留位置，本身无内容，在文件中不占据空间。

![屏幕快照 2018-08-25 11.05.20](屏幕快照 2018-08-25 11.05.20.png)

ELF 文件的开头是一个**文件头**，包含了整个文件的文件属性；并且有一个**段表**（Section Table），即一个描述文件中各个段的数组，包括段在文件中的**偏移位置**和段的**属性**等。

分段的**好处**

- 将数据和指令分别映射到两个虚存区域，权限分别为读写和只读；
- 提高程序的局部性；
- CPU 缓存被设计为数据缓存和指令缓存，分段有助于提高缓存命中率；
- 运行多个该程序的副本时，指令是一样的，只需要保存不同的数据。

## 目标文件详细

主要段示意：

![屏幕快照 2018-08-25 11.19.12](屏幕快照 2018-08-25 11.19.12.png)

![屏幕快照 2018-08-25 11.19.23](屏幕快照 2018-08-25 11.19.23.png)

可以看到文件还包含**只读数据段**（.rodata，包括常量，字符等），**注释信息段**（.comment）和**堆栈提示段**（.note.GUN-stack）；.bss段没有 'CONTENTS'，表示其在ELF文件中不存在内容。

### 段表

ELF 文件的段结构由段表决定。

![屏幕快照 2018-08-25 11.34.51](屏幕快照 2018-08-25 11.34.51.png)

对编译器、链接器来说，最重要的就是**段的类型**，**段的标志位**和**段的链接信息**。

.rel.text 段的类型为 SHT_REL，是一个**重定位表**。对于每一个必须要重定位的代码段和数据段，都会有一个相对应的重定位表。注意到.text 中就有对 `printf` 的引用。

ELF 文件中用到了很多字符串，如段名、字符串变量等等。目标文件中有两个段，**字符串表** .strtab 用来保存普通的字符串，如符号名等，和**段表字符串表** .shstrtab 用来保存段表中用到的字符串，如段名等。

## 符号

源代码中的变量、函数统称为**符号**。

目标文件A **定义**了某个符号，而目标文件B **引用**了该符号。

链接过程很关键的一部分就是符号的管理；整个链接过程正是基于符号才能够正确完成。

符号可以分为：

- 定义在本目标文件中的**全局符号**；
- 目标文件引用的**外部符号**；
- 段名；
- 只在编译单元内部可见的**局部符号**。
- 行号信息。

显然这里我们只关心上面的第一类和第二类。因为链接过程只关注全局符号的相互粘合。

ELF 文件中有 .symtab 段来作为符号表，主要的属性有：

- 符号类型和绑定信息；
- 符号所在的段；
- 符号值：
  - 在目标文件中，是符号的定义且不在 common 块的，值为该符号在所在段中的偏移；
  - 在目标文件中，为 common 块类型的，值表示该符号的对其属性。
  - 在可执行文件中，符号值为其虚拟地址。

### 特殊符号

ld 链接器在链接过程中会产生一些特殊符号。虽然我们没有定义它们，但我们却可以在程序中使用，如`_executable_start`，`_end` 等来控制编译链接。

### 符号修饰

当工程较大时，会产生命名冲突。部分编译器会在符号名前加入下划线 _ 来修饰。

C++ 则更为复杂，会有**符号修饰**（Name Decoration）和**符号改编**（Name Mangling）。典型的就是**函数签名**。

函数签名包含了函数的信息，包括函数名，参数类型，所在的类和名称空间等等。

编译器使用的是**修饰后名称**，用以区分同名函数。

GCC 的C++ 基本名称修饰**规则**如下：所有符号都以 _Z 开头，对于嵌套（在类或名称空间中）的符号，后面紧跟 N，然后是名称空间和类的名字，名字前是该名字字符串的长度，再以 E 结尾。若是函数，其参数列表紧跟在 E 后面。

| 函数签名            | 修饰后名称     |
| ------------------- | -------------- |
| int func(int)       | _Z4funci       |
| int C::func(float)  | _ZN1C4funcEf   |
| int N::C::func(int) | _ZN1N1C4funcEi |

不同的编译器采用不同的名称修饰方法，这是不同编译器不能互操作的主要原因。

### extern "C"

C++ 编译器会在 `extern "C"` 的大括号内部的代码当作C语言代码处理。

而C++编译器会在编译时默认定义宏`__cplusplus`，我们可以以此来判断当前编译单元是不是C++代码。

### 强符号和弱符号

编译器默认**函数**和**初始化了的全局变量**为*强符号*，**未初始化的全局变量**为*弱符号*。

**规则**：

1. 不允许强符号多次定义：符号重复定义错误；
2. 某个符号有一个强符号定义，多个弱符号，以强符号为准；
3. 都为弱符号，则选择占用空间最大的那个。

若链接时，未找到某个符号的定义，链接器报符号未定义错误，这种被称为*强引用*。而在处理*弱引用*时，如果该符号有定义，则链接器将该符号的引用决议；若未定义也不报错。

对于未定义的弱引用，链接器默认其为零。

# 静态链接

静态链接就是将几个输入目标文件加工后合并成一个输出文件。这里主要分为两步：

1. 空间与地址分配；
2. 符号解析与重定位。

## 空间与地址分配

最简单的就是将输入的目标文件按照次序叠加起来。但这样会造成内存碎片等缺点。

### 相似段合并

更常见的做法是把性质相似的段合并到一起。

而*地址和空间的分配*有两个含义：

1. 在输出的可执行文件中分配；
2. 在装载后的虚拟地址中的虚拟地址空间分配。

对于.text 和.data 段，二者在可执行文件和虚存中都需要分配空间。对于.bss 段来说，空间分配只对后者有意义。

链接前后的程序中使用的地址已经是程序在进程中的虚拟地址。所以对于目标文件中的各段，我们只关心其VMA 和SIZE。

![屏幕快照 2018-09-09 20.41.29](屏幕快照 2018-09-09 20.41.29.png)

链接完后，输入文件中的各个段的虚拟地址就已经确定了。

然后，链接器开始计算各个**符号**的虚拟地址。因为符号在段内的相对位置固定，此时只要给符号加上偏移量就可以了。

## 符号解析与重定位

### 重定位

空间分配完成后，链接就进入核心的*符号解析和重定位*步骤。

#### 符号解析

每个目标文件都有一个符号表，对于外部符号，其在符号表中的类型都是 UND，即未定义。编译完成后，编译器会产生一个有所有输入目标文件的符号表组成的**全局符号表**。当链接器扫描完所有的输入目标文件后，所有的未定义符号都应该能够在全局符号表中找到，然后进行重定位。否则就报*符号未定义*错误。

#### 重定位表

目标文件中，有一个**重定位表**的数据结构来保存与重定位相关的信息。

对于每一个需要被重定位的ELF段都有一个对应的重定位表。如对于 .text 段，会有一个 .rel.rext 段。

重定位表包含一个**重定位入口**，表示要被重定位的符号在被重定位段中的偏移，**重定位入口的类型和符号**，低8位表示重定位入口的类型，高24位表示该符号在符号表中的下标，和**指令修正方式**。

编译完成后，链接之前，在目标文件中，会将这些未定义符号的地址设置为一个假地址，并配上相对应的*指令修正方式*。链接器在完成地址和空间的分配后就可以确定所有符号的虚拟地址了，链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。

#### 指令修正方式

32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：

- 绝对近址32位寻址；
- 相对近址32位寻址。

这两种重定位方式指令修正方式每个被重定位的位置的长度都是32位，即4个字节。

 ![屏幕快照 2018-09-16 18.42.08](../../../../../Downloads/屏幕快照 2018-09-16 18.42.08.png)

其中，A 即编译器设置的假地址。

### COMMON 块

链接器本身不支持符号类型，即变量类型对链接器来说是**未知**的。

根据前面的强弱符号，则有可能出现多个符号**重复定义且类型不一致**的情况。编译器和链接器对于这种情况采用**COMMON块机制**。

编译器将为初始化的全局变量定义为*弱符号*，且在目标文件中将之设置为SHN_COMMON类型。在最后的链接过程中，

- 若该变量在其他文件中也为弱符号，该变量的大小将以输入目标文件中最大的为准；
- 若其中有一个强符号，则最终输出结果中的符号占用空间与强符号相同（，如果有弱符号的大小大于强符号，链接器会告警）。

当链接器读取所有输入文件后，所有符号的最终大小都可以确定了。因此链接器将在输出文件的.bss段为弱符号分配空间（和为初始化的静态变量一样）。

## C++ 相关问题

### 重复代码消除

C++ 编译器在很多时候会产生重复代码，如*模板*，*外部内连函数*和*虚函数表*。造成的**问题**：

- **空间浪费**：一个模板在多个文件实例化为同种类型；
- **地址出错**：指向同一个函数的指针不同；
- **指令运行效率低**：一个指令多个副本，Cache命中率降低。

**解决**：目前比较有效的做法就是将每个模板的实例代码都单独存放在一个段中，每个段只包含一个模板实例。链接的时候，链接器就可以区分相同的模板实例段，将它们并入最后的代码段。

**问题**：但相同名称的段可能会有不同的内容（不同编译器所致）。此时链接器会选择其中一个版本作为输入并给出告警信息。

### 函数级别链接

某个库可能包含了许多函数但只用到其中一个，链接整个库会造成上时间和空间上的浪费。编译器提供了**函数级别链接**的选项。**作用**就是将被用到的函数如前所述的模板示例一样单独放到一个段里，抛弃没用到的函数。这样可以**减少空间浪费**。

**缺点**：减慢编译和链接过程：链接器要计算各函数间的依赖关系；目标文件的段数量会大大增加，重定位过程变得更复杂。

### 全局构造与析构

在main函数执行前，进程要初始化进程执行环境。如C++ 全局对象的构造和析构就在main函数之前和之后进行。

ELF文件定义了两个特殊段：

- .init 段：保存可执行指令，构成来进程的初始化代码；
- .fini 段：保存进程终止代码指令。

因此，将某个函数放到 .init 段中，系统就会在执行main函数前执行它。

### ABI

API 描述的接口是源代码级别的接口；而 ABI 则是二进制层面的接口。其中，*符号修饰标准*、*变量内存布局*、函数调用方式等与*可执行代码二进制兼容性*相关的内容称为ABI。

影响 ABI 的因素非常多，硬件、编程语言、编译器链接器、操作系统等。因此不同编译器产生的目标文件很难兼容。而C++ 复杂的语言特性更是加剧了这种情况。

## 静态库链接

一种语言的开发环境往往会附带语言库，这些都是对操作系统API 的包装。一个静态库可以看成是一组目标文件的集合，即多个目标文件经过压缩打包后形成的一个文件（.lib）。

### 链接过程控制

连接器的三种使用方式：

1. 

